---
layout: post
title: 内存与线程
tags:
  - Memory
  - Thread
  - Thread-Lock
categories:
  - tech
  - Thread
abbrlink: 86432bb
date: 2019-08-16 12:00:00
---

大家在平常学习的过程中可能会接触到线程安全这个词，知道线程可能不安全，却不清楚是怎么回事，这里就给大家简单介绍一下，有错误请下方评论指正。

## 内存

首先，内存大致可以分为栈内存、堆内存和静态存储区。

* 栈内存：程序自动分配和释放，主要储存局部变量，临时变量等
* 堆内存：由程序员自己申请分配和释放，典型的通过new来创建的对象就是储存在堆内存中
* 静态存储区：整个程序运行期间都存在，储存常量、静态数据、全局数据等

## 调用对象

知道了内存的存储规则，我们还要知道对象在被调用时会发生什么。

```java
public class Test {
    private int a = 0;
    public void add() { a++; }
}
```

以Java为例，上面的代码可以看出，每当调用一次Test对象的add方法，a就会自增1。那么它究竟是怎么实现自增的呢？

请看下图：

![thread-safe][thread-safe]

根据上图示意，我们可以很清楚的知道，程序再调用test的add方法时，先复制了一份test到栈内存中，在栈内存中完成自增操作，之后再赋值回堆内存中的test对象。

相信聪明的你们已经发现问题所在了。

## 线程安全

当多个线程同时调用test对象时，如果某个线程在复制完test的值后被挂起，没有来得及赋值回去，而其他线程又调用了test对象的add方法，那么可想而知，他们复制到的值都是0，在自增完后赋值回去，当两个线程都执行完操作后，本来执行了两次自增操作的值应为2，现在只有1，这就是线程不安全导致的。由于cpu对线程资源的分配是随机的，就像悬在程序头上的达摩克利斯之剑，随时会落下造成致命一击。

为了解决这个问题，让程序在执行写操作时保证不会出错，我们就需要引入线程锁。当你给一个类或者一个方法添加锁之后，在你完成对某个对象的操作之前，其他线程一律无法访问该对象，确保操作安全。

## synchronized与Lock

标题中的两个词，都可以给线程加锁。第一个**synchronized**是Java内置的关键字，通过添加在类名或者方法名之前，可以给相应的对象加上锁。

**Lock**则是Java库中的一个类，因为**synchronized**功能简单粗暴，有时会造成许多不便，所以使用**Lock**是更好的选择。当然有一点需要注意，**synchronized**关键字释放锁是自动进行的，而**Lock**则需要手动释放。

更详细的知识此处就不介绍了，大家有兴趣可以自己深入学习。

[thread-safe]: http://static.wilfredshen.cn/images/Memory%20and%20Thread/thread-safe.png
